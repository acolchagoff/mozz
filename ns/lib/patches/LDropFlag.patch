*** Develop:Source331 Build Environment:CW Pro 2:Metrowerks CodeWarrior:MacOS Support:PowerPlant:_In Progress:_Table Classes:LDropFlag.cp	Mon Mar 16 17:12:01 1998--- Source:LDropFlag.cp	Mon Mar 16 17:12:07 1998****************** 1,6 ****--- 1,7 ----  // ===========================================================================  //	LDropFlag.cp			   ©1995-1996 Metrowerks Inc. All rights reserved.  // ===========================================================================+ //¥¥¥NETSCAPE - draw over bg colors other than white (ie, preserve bg color)  //  //	Draws and tracks clicks for a drop flag.  ****************** 9,20 ****--- 10,26 ----  #endif    #include <LDropFlag.h>+ #include <UGWorld.h>    #ifndef __ICONS__  #include <Icons.h>  #endif    + //¥¥¥NETSCAPE+ static void PlotIconOffscreen ( const Rect & inRect, ResIDT inIconID ) ;+ +   //	Icon family resource ID's for the states of the drop flag  //	The size of the rectangle you pass to Draw and TrackClick determine  //	which icon size gets used.****************** 47,53 ****  		iconID = icon_Down;  	}  ! 	::PlotIconID(&inRect, atNone, ttNone, iconID);  }    --- 53,60 ----  		iconID = icon_Down;  	}  ! //¥¥¥NETSCAPE - call PlotIconOffscreen() instead of PlotIconID()! 	PlotIconOffscreen ( inRect, iconID );	  }    ****************** 64,70 ****  //	inIsUp specifies if the flag was up or down when the click started  //  //	Returns whether the mouse was release inside the DropFlag.!   Boolean  LDropFlag::TrackClick(  	const Rect	&inRect,--- 71,78 ----  //	inIsUp specifies if the flag was up or down when the click started  //  //	Returns whether the mouse was release inside the DropFlag.! //! //¥¥¥NETSCAPE - call PlotIconOffscreen() instead of PlotIconID()  Boolean  LDropFlag::TrackClick(  	const Rect	&inRect,****************** 87,93 ****  									// when it was previously outside  	Boolean		currInside = true;  	Boolean		prevInside = false;! 	::PlotIconID(&inRect, atNone, ttNone, iconID + 1);  	  									// Track the mouse while it is down  	Point	currPt = inMouse;--- 95,101 ----  									// when it was previously outside  	Boolean		currInside = true;  	Boolean		prevInside = false;! 	PlotIconOffscreen(inRect, iconID + 1);  	  									// Track the mouse while it is down  	Point	currPt = inMouse;****************** 101,107 ****  			if (currInside) {  				trackIconID = iconID + 1;  			}! 			::PlotIconID(&inRect, atNone, ttNone, trackIconID);  		}  	}  	--- 109,115 ----  			if (currInside) {  				trackIconID = iconID + 1;  			}! 			PlotIconOffscreen(inRect, trackIconID);  		}  	}  	****************** 116,122 ****  	if (goodClick) {  		UInt32	ticks;				// Draw intermediate state  		::Delay(delay_Animation, &ticks);! 		::PlotIconID(&inRect, atNone, ttNone, icon_Side);  		::Delay(delay_Animation, &ticks);  		  									// Draw dark end state--- 124,130 ----  	if (goodClick) {  		UInt32	ticks;				// Draw intermediate state  		::Delay(delay_Animation, &ticks);! 		PlotIconOffscreen(inRect, icon_Side);  		::Delay(delay_Animation, &ticks);  		  									// Draw dark end state****************** 124,137 ****  		if (inIsDown) {  			endIconID = icon_Up + 1;  		}! 		::PlotIconID(&inRect, atNone, ttNone, endIconID);  		::Delay(delay_Animation, &ticks);  									// Draw normal end state! 		::PlotIconID(&inRect, atNone, ttNone, endIconID - 1);  		  	} else {						// Draw original state! 		::PlotIconID(&inRect, atNone, ttNone, iconID);  	}  		  	return goodClick;  }--- 132,170 ----  		if (inIsDown) {  			endIconID = icon_Up + 1;  		}! 		PlotIconOffscreen(inRect, endIconID);  		::Delay(delay_Animation, &ticks);  									// Draw normal end state! 		PlotIconOffscreen(inRect, endIconID - 1);  		  	} else {						// Draw original state! 		PlotIconOffscreen(inRect, iconID);  	}  		  	return goodClick;+ }+ + + //¥¥¥ NETSCAPE+ // this code is mainly from LGADisclosureTriangle.cp+ static void PlotIconOffscreen ( const Rect & inRect, ResIDT inIconID )+ {+ 	// ¥ In order to make the transitions between the various states+ 	// smoother we are going to attempt to figure out what the background+ 	// color is behind the triangle, by using the current clipping region+ 	// we will subzequently use this color to wipe the background+ 	Rect destRect;+ 	RgnHandle currClip = ::NewRgn ();+ 	::GetClip ( currClip );+ 	Rect clipRect = (**currClip).rgnBBox;+ 	::DisposeRgn ( currClip );+ 	::SectRect ( &inRect, &clipRect, &destRect );+ + 	RGBColor backColor; + 	::GetCPixel ( destRect.right - 1, destRect.top, &backColor );+ 	StOffscreenGWorld world(inRect);+ 	::RGBBackColor ( &backColor );+ 	::EraseRect ( &inRect );+ + 	::PlotIconID(&inRect, atNone, ttNone, inIconID);  }